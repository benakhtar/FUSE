/*
* MIT License
*
* Copyright (c) 2022 Nora Khayata
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

#include <gtest/gtest.h>

#include <algorithm>
#include <bitset>
#include <climits>
#include <filesystem>
#include <fstream>
#include <regex>
#include <string>

#include "BristolFrontend.h"
#include "IOHandlers.h"
#include "IR.h"
#include "PlaintextInterpreter.hpp"

namespace fuse::tests::backend {

std::unordered_map<uint64_t, bool> prepareEnvironment(const core::CircuitReadOnly& circ, std::string numberToRepresent) {
    auto in = circ.getNumberOfInputs();
    auto size = numberToRepresent.size();
    assert(in == size);
    std::unordered_map<uint64_t, bool> result;
    auto inputs = circ.getInputNodeIDs();
    size_t currentCharPosition = 0;

    for (char binaryChar : numberToRepresent) {
        if (binaryChar == '0') {
            result[inputs[currentCharPosition]] = false;

        } else {
            result[inputs[currentCharPosition]] = true;
        }
        ++currentCharPosition;
    }

    return result;
}

std::string prepareOutput(const core::CircuitReadOnly& circ, const std::unordered_map<uint64_t, bool>& environment) {
    std::stringstream result;
    for (auto output : circ.getOutputNodeIDs()) {
        result << environment.at(output);
    }
    return result.str();
}

// https://homes.esat.kuleuven.be/~nsmart/MPC/md5-test.txt
TEST(PlaintextInterpreterTest, MD5) {
    namespace io = fuse::core::util::io;
    std::string md5 = "../../examples/bristol_circuits/md5.bristol";
    std::string md5FB = "../../examples/bristol_circuits/md5.fs";

    // get test case
    ASSERT_NO_THROW(frontend::loadFUSEFromBristolToFile(md5, md5FB));
    core::CircuitContext context;
    core::CircuitBufferWrapper circ = context.readCircuitFromFile(md5FB);

    // prepare environment

    // interpret MD5 circuit
    fuse::backend::PlaintextInterpreter<bool> interpreter;
    std::bitset<512> input;

    // in:  00000000000000000000000000000000 (hex)
    // out: 10101100000111010001111100000011110100001000111010100101011011101011011101100111101010110001111110010001011101110011000101110100 (binary)
    input = 0;
    auto env = prepareEnvironment(circ, input.to_string());
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "10101100000111010001111100000011110100001000111010100101011011101011011101100111101010110001111110010001011101110011000101110100");

    // unpack circuit and test again
    auto unpacked = context.getMutableCircuitWrapper();
    ASSERT_NO_THROW(interpreter.evaluate(unpacked, env));
    ASSERT_STREQ(prepareOutput(unpacked, env).c_str(), "10101100000111010001111100000011110100001000111010100101011011101011011101100111101010110001111110010001011101110011000101110100");

    // in=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f
    // out=cad94491c9e401d9385bfc721ef55f62
    env = prepareEnvironment(circ, "00000000000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111000100000001000100010010000100110001010000010101000101100001011100011000000110010001101000011011000111000001110100011110000111110010000000100001001000100010001100100100001001010010011000100111001010000010100100101010001010110010110000101101001011100010111100110000001100010011001000110011001101000011010100110110001101110011100000111001001110100011101100111100001111010011111000111111");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "11001010110110010100010010010001110010011110010000000001110110010011100001011011111111000111001000011110111101010101111101100010");

    // in=ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    // out=b487195651913e494b55c6bddf405c01
    env = prepareEnvironment(circ, "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "10110100100001110001100101010110010100011001000100111110010010010100101101010101110001101011110111011111010000000101110000000001");

    // in=243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c89452821e638d01377be5466cf34e90c6cc0ac29b7c97c50dd3f84d5b5b5470917
    // out=3715f568f422db75cc8d65e11764ff01
    env = prepareEnvironment(circ, "00100100001111110110101010001000100001011010001100001000110100110001001100011001100010100010111000000011011100000111001101000100101001000000100100111000001000100010100110011111001100011101000000001000001011101111101010011000111011000100111001101100100010010100010100101000001000011110011000111000110100000001001101110111101111100101010001100110110011110011010011101001000011000110110011000000101011000010100110110111110010010111110001010000110111010011111110000100110101011011010110110101010001110000100100010111");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "00110111000101011111010101101000111101000010001011011011011101011100110010001101011001011110000100010111011001001111111100000001");
}

TEST(PlaintextInterpreterTest, SHA_256) {
    // https://homes.esat.kuleuven.be/~nsmart/MPC/sha-256-test.txt
    namespace io = fuse::core::util::io;
    std::string test = "../../examples/bristol_circuits/sha-256-bristol.bristol";
    std::string testFB = "../../examples/bristol_circuits/sha-256.fs";

    // get test case
    ASSERT_NO_THROW(frontend::loadFUSEFromBristolToFile(test, testFB));
    core::CircuitContext context;
    core::CircuitBufferWrapper circ = context.readCircuitFromFile(testFB);

    fuse::backend::PlaintextInterpreter<bool> interpreter;
    std::unordered_map<uint64_t, bool> env;

    // in:  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    // out: da5698be17b9b46962335799779fbeca8ce5d491c0d26243bafef9ea1837a9d8
    env = prepareEnvironment(circ, "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "1101101001010110100110001011111000010111101110011011010001101001011000100011001101010111100110010111011110011111101111101100101010001100111001011101010010010001110000001101001001100010010000111011101011111110111110011110101000011000001101111010100111011000");

    // in=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f
    // out=fc99a2df88f42a7a7bb9d18033cdc6a20256755f9d5b9a5044a9cc315abe84a7
    env = prepareEnvironment(circ, "00000000000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111000100000001000100010010000100110001010000010101000101100001011100011000000110010001101000011011000111000001110100011110000111110010000000100001001000100010001100100100001001010010011000100111001010000010100100101010001010110010110000101101001011100010111100110000001100010011001000110011001101000011010100110110001101110011100000111001001110100011101100111100001111010011111000111111");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "1111110010011001101000101101111110001000111101000010101001111010011110111011100111010001100000000011001111001101110001101010001000000010010101100111010101011111100111010101101110011010010100000100010010101001110011000011000101011010101111101000010010100111");

    // in=ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    // out=ef0c748df4da50a8d6c43c013edc3ce76c9d9fa9a1458ade56eb86c0a64492d2
    env = prepareEnvironment(circ, "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "1110111100001100011101001000110111110100110110100101000010101000110101101100010000111100000000010011111011011100001111001110011101101100100111011001111110101001101000010100010110001010110111100101011011101011100001101100000010100110010001001001001011010010");

    // in=243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c89452821e638d01377be5466cf34e90c6cc0ac29b7c97c50dd3f84d5b5b5470917
    // out=cf0ae4eb67d38ffeb94068984b22abde4e92bc548d14585e48dca8882d7b09ce
    env = prepareEnvironment(circ, "00100100001111110110101010001000100001011010001100001000110100110001001100011001100010100010111000000011011100000111001101000100101001000000100100111000001000100010100110011111001100011101000000001000001011101111101010011000111011000100111001101100100010010100010100101000001000011110011000111000110100000001001101110111101111100101010001100110110011110011010011101001000011000110110011000000101011000010100110110111110010010111110001010000110111010011111110000100110101011011010110110101010001110000100100010111");
    ASSERT_NO_THROW(interpreter.evaluate(circ, env));
    ASSERT_STREQ(prepareOutput(circ, env).c_str(), "1100111100001010111001001110101101100111110100111000111111111110101110010100000001101000100110000100101100100010101010111101111001001110100100101011110001010100100011010001010001011000010111100100100011011100101010001000100000101101011110110000100111001110");
}

}  // namespace fuse::tests::backend
